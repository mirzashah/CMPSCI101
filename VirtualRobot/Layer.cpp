#include "Layer.h"
#include "Engine.h"
#include <iostream>
using std::cout;
using std::endl;


namespace Beeber
{



/*****************************************************************************/
Layer::Layer()
/*****************************************************************************/
{

}

/*****************************************************************************/
Layer::~Layer()
/*****************************************************************************/
{
}


/*****************************************************************************/
XYPoint Layer::Center()
/*****************************************************************************/
{
   return(GetEngine().Center());
}

/*****************************************************************************/
void Layer::Center(XYPoint p)
/*****************************************************************************/
{
   GetEngine().Center(p);
}

/*****************************************************************************/
XYExtents Layer::Extents()
/*****************************************************************************/
{
   return(GetEngine().Extents());
}

/*****************************************************************************/
double Layer::ExtentLeft()
/*****************************************************************************/
{
   return(GetEngine().ExtentLeft());
}

/*****************************************************************************/
double Layer::ExtentRight()
/*****************************************************************************/
{
   return(GetEngine().ExtentRight());
}

/*****************************************************************************/
double Layer::ExtentTop()
/*****************************************************************************/
{
   return(GetEngine().ExtentTop());
}

/*****************************************************************************/
double Layer::ExtentBottom()
/*****************************************************************************/
{
   return(GetEngine().ExtentBottom());
}

/*****************************************************************************/
double Layer::Scale()
/*****************************************************************************/
{
   return(GetEngine().Scale());
}

/*****************************************************************************/
void Layer::Scale(double scale)
/*****************************************************************************/
{
   GetEngine().Scale(scale);
}

/*****************************************************************************/
int Layer::WidthInPixels()
/*****************************************************************************/
{
   return(GetEngine().WidthInPixels());
}

/*****************************************************************************/
int Layer::HeightInPixels()
/*****************************************************************************/
{
   return(GetEngine().HeightInPixels());
}

/*****************************************************************************/
DevicePoint Layer::XY2Device(XYPoint p)
/*****************************************************************************/
{
   return(GetEngine().XY2Device(p));
}

/*****************************************************************************/
XYPoint Layer::Device2XY(DevicePoint p)
/*****************************************************************************/
{
   return(GetEngine().Device2XY(p));
}

/*****************************************************************************/
bool Layer::IsMouseButtonDown(MouseButton button)
/*****************************************************************************/
{
   return(GetEngine().IsMouseButtonDown(button));
}

/*****************************************************************************/
XYPoint Layer::LastMousePosition()
/*****************************************************************************/
{
   return(GetEngine().LastMousePosition());
}

/*****************************************************************************/
DevicePoint Layer::LastMousePositionDevice()
/*****************************************************************************/
{
   return(GetEngine().LastMousePositionDevice());
}

/*****************************************************************************/
XYPoint Layer::MousePosition()
/*****************************************************************************/
{
   return(GetEngine().MousePosition());
}

/*****************************************************************************/
DevicePoint Layer::MousePositionDevice()
/*****************************************************************************/
{
   return(GetEngine().MousePositionDevice());
}

/*****************************************************************************/
bool Layer::IsInSimulationMode()
/*****************************************************************************/
{
   return(BeeberConfig().IsSimulationInDisplayEnabled());
}

/*****************************************************************************/
void Layer::OnDraw()
/*****************************************************************************/
{
   //No-op
}

/*****************************************************************************/
void Layer::OnTimer()
/*****************************************************************************/
{

}

/*****************************************************************************/
int Layer::TimerDurationInMilliseconds()
/*****************************************************************************/
{
   return(GetEngine().TimerDurationInMilliseconds());
}

/*****************************************************************************/
void Layer::ProcessIncomingMessage(const BeeberMessage& msg)
/*****************************************************************************/
{
   //cout << "Processing incoming message: " << msg.id << "Type = " << BeeberMessageTypeToString(msg.type) << endl;
   switch(msg.type)
   {
      case(BMT_SENSOR_RPT):
         OnIncomingMessage(msg.timestamp, msg.sensorRpt); break;
      case(BMT_EMOTION_RPT):
         OnIncomingMessage(msg.timestamp, msg.emotionRpt); break;
      case(BMT_OBSTACLE_RPT):
         OnIncomingMessage(msg.timestamp, msg.obstacleRpt); break;
      default:
         break; //Ignoring others...
   };
}

/*****************************************************************************/
void Layer::ProcessIncomingMessages(const BeeberMessageList& msgs)
/*****************************************************************************/
{
   for(unsigned int c=0; c<msgs.size(); c++)
      ProcessIncomingMessage(msgs.at(c));
}

};
